# GitLab CI/CD Pipeline for Azure Kubernetes Service
# 
# This pipeline uses Helm for Kubernetes deployments.
# Helm charts are located in infrastructure/helm/<service-name>/
# 
# Pipeline Stages:
# 1. Validate Infrastructure - Validate Terraform/Bicep/ARM templates
# 2. Plan Infrastructure - Generate deployment plan (Terraform)
# 3. Deploy Infrastructure - Deploy infrastructure to environments (optional, separate pipeline recommended)
# 4. Build - Compile backend services
# 5. Test - Run unit tests
# 6. Security Scan - Vulnerability scanning
# 7. Validate Helm - Validate Helm charts
# 8. Build Images - Build and push Docker images to ACR
# 9. Deploy Dev - Deploy to dev environment using Helm
# 10. Integration Tests - Run integration tests
# 11. Deploy Staging - Deploy to staging using Helm
# 12. E2E Tests - End-to-end tests
# 13. Deploy Production - Manual deployment to production using Helm
#
# Infrastructure Deployment:
# - Infrastructure deployment is typically done in a separate pipeline or manually
# - Uncomment infrastructure deployment stages if you want to deploy infrastructure via CI/CD
# - See INFRASTRUCTURE_DEPLOYMENT_GUIDE.md for detailed examples and best practices
#
# Application Deployment:
# To deploy a different service, override SERVICE_NAME variable in the job or use CI/CD variables.
# Example: Set CI/CD variable SERVICE_NAME=product-service to deploy product service

stages:
  # Infrastructure stages (optional - uncomment if deploying infrastructure via CI/CD)
  # - validate-infrastructure
  # - plan-infrastructure
  # - deploy-infrastructure-dev
  # - deploy-infrastructure-staging
  # - deploy-infrastructure-production
  # Application stages
  - build
  - test
  - security-scan
  - validate-helm
  - build-images
  - deploy-dev
  - integration-tests
  - deploy-staging
  - e2e-tests
  - deploy-production

variables:
  ACR_NAME: acrcsomplatform
  AKS_RESOURCE_GROUP: rg-csom-platform-prod
  AKS_CLUSTER_NAME: aks-csom-platform-prod
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  HELM_VERSION: "3.13.0"
  # Service to deploy (can be overridden per job or via CI/CD variables)
  SERVICE_NAME: "order-service"

# Build stage for backend services
build-backend:
  stage: build
  image: maven:3.9-eclipse-temurin-17
  script:
    - cd backend/order-service
    - mvn clean compile
  only:
    - merge_requests
    - main
    - develop

# Test stage
test-backend:
  stage: test
  image: maven:3.9-eclipse-temurin-17
  script:
    - cd backend/order-service
    - mvn test
  coverage: '/Total.*?([0-9]{1,3})%/'
  artifacts:
    reports:
      junit: backend/order-service/target/surefire-reports/TEST-*.xml
  only:
    - merge_requests
    - main
    - develop

# Security scan
security-scan:
  stage: security-scan
  image: 
    name: aquasec/trivy:latest
    entrypoint: [""]
  script:
    - trivy fs --severity HIGH,CRITICAL --exit-code 1 backend/
  allow_failure: true
  only:
    - merge_requests
    - main

# Validate Helm charts
# This job validates Helm charts before deployment
validate-helm-charts:
  stage: validate-helm
  image: alpine/helm:latest
  script:
    - cd infrastructure/helm/$SERVICE_NAME
    - echo "Validating Helm chart for $SERVICE_NAME"
    - helm lint .
    - helm template $SERVICE_NAME . --values values-dev.yaml --debug > /dev/null
    - echo "Helm chart validation passed"
  allow_failure: false
  only:
    - merge_requests
    - main
    - develop

# ==============================================================================
# Infrastructure Deployment (Optional - Uncomment to enable)
# ==============================================================================
# 
# Infrastructure deployment via CI/CD is optional. You can:
# 1. Deploy infrastructure manually (see INFRASTRUCTURE_DEPLOYMENT_GUIDE.md)
# 2. Use a separate infrastructure pipeline
# 3. Uncomment the stages below to deploy infrastructure in this pipeline
#
# Note: Infrastructure deployment should typically happen before application
# deployment. If using this pipeline, uncomment the infrastructure stages above.
#
# ==============================================================================

# Validate Infrastructure - Terraform
# validate-terraform:
#   stage: validate-infrastructure
#   image: hashicorp/terraform:latest
#   before_script:
#     - cd infrastructure/terraform
#   script:
#     - terraform init -backend=false
#     - terraform validate
#     - terraform fmt -check
#   only:
#     - merge_requests
#     - main
#     - develop
#   allow_failure: false

# Validate Infrastructure - Bicep
# validate-bicep:
#   stage: validate-infrastructure
#   image: mcr.microsoft.com/azure-cli:latest
#   before_script:
#     - az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
#   script:
#     - cd infrastructure/bicep
#     - az bicep build --file main.bicep
#     - az deployment group validate \
#         --resource-group $RESOURCE_GROUP \
#         --template-file main.bicep \
#         --parameters @main.parameters.json
#   only:
#     - merge_requests
#     - main
#     - develop
#   allow_failure: false

# Deploy Infrastructure - Terraform (Development)
# deploy-terraform-dev:
#   stage: deploy-infrastructure-dev
#   image: hashicorp/terraform:latest
#   before_script:
#     - az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
#     - cd infrastructure/terraform
#     - terraform init
#       -backend-config="storage_account_name=$TF_STATE_STORAGE_ACCOUNT"
#       -backend-config="container_name=$TF_STATE_CONTAINER"
#       -backend-config="key=dev/terraform.tfstate"
#       -backend-config="resource_group_name=$TF_STATE_RESOURCE_GROUP"
#   script:
#     - terraform workspace select dev || terraform workspace new dev
#     - terraform plan -out=tfplan-dev -var-file=terraform.tfvars.dev
#     - terraform apply -auto-approve tfplan-dev
#   environment:
#     name: dev
#   only:
#     - develop
#   when: manual

# Deploy Infrastructure - Bicep (Development)
# deploy-bicep-dev:
#   stage: deploy-infrastructure-dev
#   image: mcr.microsoft.com/azure-cli:latest
#   before_script:
#     - az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
#     - az group create --name rg-csom-platform-dev --location westeurope || true
#   script:
#     - cd infrastructure/bicep
#     - |
#       az deployment group create \
#         --resource-group rg-csom-platform-dev \
#         --template-file main.bicep \
#         --parameters @main.parameters.dev.json \
#         --name csom-platform-dev-${CI_COMMIT_SHORT_SHA} \
#         --mode Incremental
#   environment:
#     name: dev
#   only:
#     - develop
#   when: manual

# Deploy Infrastructure - Production (Manual Approval Required)
# deploy-terraform-production:
#   stage: deploy-infrastructure-production
#   image: hashicorp/terraform:latest
#   before_script:
#     - az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
#     - cd infrastructure/terraform
#     - terraform init
#       -backend-config="storage_account_name=$TF_STATE_STORAGE_ACCOUNT"
#       -backend-config="container_name=$TF_STATE_CONTAINER"
#       -backend-config="key=production/terraform.tfstate"
#       -backend-config="resource_group_name=$TF_STATE_RESOURCE_GROUP"
#   script:
#     - terraform workspace select production || terraform workspace new production
#     - terraform plan -out=tfplan-production -var-file=terraform.tfvars.production
#     - terraform apply -auto-approve tfplan-production
#   environment:
#     name: production
#   only:
#     - main
#     - tags
#   when: manual

# Deploy Infrastructure - Bicep (Production)
# deploy-bicep-production:
#   stage: deploy-infrastructure-production
#   image: mcr.microsoft.com/azure-cli:latest
#   before_script:
#     - az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
#     - az group create --name rg-csom-platform-prod --location westeurope || true
#   script:
#     - cd infrastructure/bicep
#     - |
#       az deployment group create \
#         --resource-group rg-csom-platform-prod \
#         --template-file main.bicep \
#         --parameters @main.parameters.prod.json \
#         --name csom-platform-prod-${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}} \
#         --mode Incremental
#   environment:
#     name: production
#   only:
#     - main
#     - tags
#   when: manual

# ==============================================================================
# Application Deployment
# ==============================================================================

# Build Docker images
build-docker-images:
  stage: build-images
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - docker login $ACR_NAME.azurecr.io -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET
  script:
    - cd backend/$SERVICE_NAME
    - docker build -t $ACR_NAME.azurecr.io/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA .
    - docker build -t $ACR_NAME.azurecr.io/$SERVICE_NAME:latest .
    - docker push $ACR_NAME.azurecr.io/$SERVICE_NAME:$CI_COMMIT_SHORT_SHA
    - docker push $ACR_NAME.azurecr.io/$SERVICE_NAME:latest
  only:
    - main
    - develop

# Deploy to Dev using Helm
deploy-dev:
  stage: deploy-dev
  image: alpine/helm:latest
  before_script:
    - apk add --no-cache curl azure-cli kubectl
    - az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
    - az aks get-credentials --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER_NAME
    - kubectl create namespace dev --dry-run=client -o yaml | kubectl apply -f -
  script:
    - cd infrastructure/helm/$SERVICE_NAME
    - |
      helm upgrade --install $SERVICE_NAME . \
        --namespace dev \
        --values values-dev.yaml \
        --set image.repository=$ACR_NAME.azurecr.io/$SERVICE_NAME \
        --set image.tag=$CI_COMMIT_SHORT_SHA \
        --wait \
        --timeout 5m
    - echo "Deployment successful. Release: $SERVICE_NAME in namespace: dev"
  environment:
    name: dev
    url: https://dev-api.example.com
  only:
    - develop

# Integration tests
integration-tests:
  stage: integration-tests
  image: maven:3.9-eclipse-temurin-17
  script:
    - cd backend/order-service
    - mvn verify -Pintegration-tests
  dependencies:
    - deploy-dev
  only:
    - develop
    - main

# Deploy to Staging using Helm
deploy-staging:
  stage: deploy-staging
  image: alpine/helm:latest
  before_script:
    - apk add --no-cache curl azure-cli kubectl
    - az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
    - az aks get-credentials --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER_NAME
    - kubectl create namespace staging --dry-run=client -o yaml | kubectl apply -f -
  script:
    - cd infrastructure/helm/$SERVICE_NAME
    - |
      helm upgrade --install $SERVICE_NAME . \
        --namespace staging \
        --values values-staging.yaml \
        --set image.repository=$ACR_NAME.azurecr.io/$SERVICE_NAME \
        --set image.tag=$CI_COMMIT_SHORT_SHA \
        --wait \
        --timeout 5m
    - echo "Deployment successful. Release: $SERVICE_NAME in namespace: staging"
  environment:
    name: staging
    url: https://staging-api.example.com
  only:
    - main

# E2E tests
e2e-tests:
  stage: e2e-tests
  image: node:20
  script:
    - cd frontend/shell
    - npm install
    - npm run test:e2e
  dependencies:
    - deploy-staging
  only:
    - main

# Deploy to Production using Helm (with manual approval)
deploy-production:
  stage: deploy-production
  image: alpine/helm:latest
  before_script:
    - apk add --no-cache curl azure-cli kubectl
    - az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
    - az aks get-credentials --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER_NAME
    - kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -
  script:
    - cd infrastructure/helm/$SERVICE_NAME
    - |
      # Use tag or commit SHA for production
      IMAGE_TAG=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}
      helm upgrade --install $SERVICE_NAME . \
        --namespace production \
        --values values-prod.yaml \
        --set image.repository=$ACR_NAME.azurecr.io/$SERVICE_NAME \
        --set image.tag=$IMAGE_TAG \
        --wait \
        --timeout 10m
    - echo "Deployment successful. Release: $SERVICE_NAME in namespace: production"
    - echo "Image tag: ${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}"
  environment:
    name: production
    url: https://api.example.com
  when: manual
  only:
    - main
    - tags

